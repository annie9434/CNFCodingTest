## 문제
틱택토는 두 사람이 하는 게임으로 처음에 3*3의 빈칸으로 이루어진 게임판에 선공이 “O”, 후공이 “X”를 번갈아 가면서 빈칸에 표시하는 게임입니다. 가로, 세로, 대각선으로 3개가 같은 표시가 만들어지면 같은 표시를 만든 사람이 승리하고 게임이 종료되며 9칸이 다 차서 더 이상 표시를 할 수 없는 경우에는 무승부로 게임이 종료됩니다.

할일이 없어 한가한 머쓱이는 두 사람이 하는 게임인 틱택토를 다음과 같이 혼자서 하려고 합니다.

- 혼자서 선공과 후공을 둘 다 맡는다.
- 틱택토 게임을 시작한 후 “D”와 “X”를 번갈아 가면서 표시를 하면서 진행한다.

틱택토는 단순한 규칙으로 게임이 금방 끝나기에 머쓱이는 한 게임이 종료되면 3*3 빈칸을 그린 뒤 다시 게임을 반보갰습니다. 그렇게 틱태토 수 십 판을 했더니 머쓱이는 게임 도중에 다음과 같이 규칙을 어기는 실수를 했을 수도 있습니다.

- “O”를 표시할 차례인데 “X”를 표시하거나 반대로 “X”를 표시할 차례인데 “O”를 표시한다.
- 선공이나 후공이 승리해서 게임이 종료되었음에도 그 게임을 진행한다.

게임 도중 게임판을 본 어느 순간 머쓱이는 본인이 실수를 했는지 의문이 생겼습니다. 혼자서 틱택토를 했기에 게임하는 과정을 지켜본 사람이 없어 이를 알 수 없습니다. 그러나 게임판만 봤을 때 실제로 틱택토 규칙을 지켜서 진행했을 때 나올 수 있는 상황인지는 판단할 수 있을 것 같고 문제가 없다면 게임을 이어서 하려고 합니다.

 머쓱이가 혼자서 게임을 진행하다가 의문이 생긴 틱택토 게임판의 정보를 담고 있는 문자열 배열 **`board`**가 매개변수로 주어질 때, 이 게임판이 규칙을 지켜서 틱택토를 진행했을 때 나올 수 있는 게임 상황이면 1을 아니라면 0을 return 하는 solution 함수를 작성해주세요.


### 입출력 예
| board | result |
| --- | --- |
| ["O.X", ".O.", "..X"] | 1 |
| ["OOO", "...", "XXX"] | 0 |
| ["...", ".X.", "..."] | 0 |
| ["...", "...", "..."] | 1 |

**입출력 예 #1**

예제 1번의 게임판은 다음과 같습니다.

| O | . | X |
| --- | --- | --- |
| . | O | . |
| . | . | X |
- 1행 1열(O) → 1행 3열(X) → 2행 2열(O) →  3행 3열(X)
- 1행 1열(O) → 3행 3열(X) → 2행 2열(O) → 1행 3열(X)
- 2행 2열(O) → 1행 3열(X) → 1행 1열(O) → 3행 3열(X)
- 2행 2열(O) → 3행 3열(X) → 1행 1열(O) → 1행 3열(X)

물론 위와 다르게 머쓱이가 2행 2열에 `O`, 3행 3열에 `X`, 1행 3열에 `X`, 1행 1열에 `O` 순서로 표시를 해서 실수를 했을 가능성도 있지만 "**실수를 했을 가능성이 있는가**"를 묻는 게 아닌 "이 게임판이 **규칙을 지켜서 진행한 틱택토에서 나올 수 있는 상황인가**"를 묻는 문제라는 것에 유의해주세요. 따라서 1을 return 합니다.


## 문제풀이
```java
	
    private char[][] cBoard;
	public int solution(String[] board) {
		cBoard = new char[board.length][board[0].length()];	 
		int oCnt = 0;
		int xCnt = 0;
		 
        // 문자열 배열을 이차원 문자 배열로 변환 및 o,x 갯수 세기
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length(); j++) {
            	char ch = board[i].charAt(j);
                cBoard[i][j] = ch;
                if(ch == 'O') oCnt+=1;
                if(ch == 'X') xCnt+=1;
            }
        }
        
        // 선공(O)의 갯수가 같거나 작으면 규칙위반
        // 1번씩 번갈아 진행하지 않은 규칙 위반
		 if(xCnt > oCnt || oCnt > xCnt + 1) {
			 return 0;
		 }
		 
		 // O가 이겼을 때 X가 O의 개수와 같으면 O가 완성되고 종료되지 않았으므로 규칙위반
		 if(checkWin('O')){
            if (oCnt == xCnt) {
                return 0;
            }
		 }
		 
		 // X가 이겼을 때 O가 X보다 1개 많은 경우 X가 완성되고 종료되지 않았으므로 규칙 위반
		 if(checkWin('X')) {
			 if (oCnt == xCnt + 1) {
	                return 0;
	         }
		 }
		 
		return 1;
    }
    
    // O나 X가 승리했는지 체크하는 로직
    public boolean checkWin(char chk) {
 
        for (int i = 0; i < 3; i++) {
            // 가로 확인
        	// 1행, 2행, 3행
            if (cBoard[i][0] == chk && cBoard[i][1] == chk && cBoard[i][2] == chk) {
                return true;
            }
            // 세로 확인
            // 1열, 2열, 3열
            if (cBoard[0][i] == chk && cBoard[1][i] == chk && cBoard[2][i] == chk) {
                return true;
            }
        }
        // 대각선 확인
        // 왼쪽 위에서 오른쪽 아래
        // 오른쪽 위에서 왼쪽 아래
        if ((cBoard[0][0] == chk && cBoard[1][1] == chk && cBoard[2][2] == chk) ||
            (cBoard[0][2] == chk && cBoard[1][1] == chk && cBoard[2][0] == chk)) {
            return true;
        }
        return false;
    }
```

### 실행시간